////////////////////////////////////////////////////////////////////////////////
// tokenizer.hpp
// Simple re2c-based for annotated or unannotated text
// TH, Sept. 2014 - June 2015
////////////////////////////////////////////////////////////////////////////////

#ifndef __TOKENIZER_HPP__
#define __TOKENIZER_HPP__

#include <string>
#include <iostream>
#include <utility>

#pragma warning( once : 4390)

/// Simple tokenizer class based on re2c
class Tokenizer
{
public:
  /// Token classes
  typedef enum { ttEOS, ttWord, ttGenSuffix, ttNumber, ttAbbrev, ttDate, ttPunct, 
                 ttLeftBracket, ttRightBracket, ttLeftQuote, ttRightQuote, ttCurrency, ttSymbol,
                 ttHTMLEntity, ttHTML_XML, ttURL, ttEmail, ttNEAnnotation, ttNEAnnotationEnd,
                 ttDash, ttMisc, ttRest, ttWhiteSpace, ttJSONEscapedSymbol, 
                 ttJSONEscapedNewline, ttJSONEscapedQuote, ttUnicodePoint } TokenType;
        
  /// Represents a token position, either in line-column-length or offset-length format
  struct TokenPosition 
  {
    TokenPosition() : line(-1), offset(-1), length(0) {}

    TokenPosition(unsigned l, unsigned o, unsigned len) : line(l), offset(o), length(len) {}

    TokenPosition(unsigned o, unsigned len) : line(-1), offset(o), length(len) {}

    bool valid() const { return offset != -1; }

    friend std::ostream& operator<<(std::ostream& o, const TokenPosition& p)
    { 
      if (p.line == -1) return o << "(" << p.offset << "," << p.length << ")";
      else return o << "(" << p.line << "," << p.offset << "," << p.length << ")";
    }

    int line;
    int offset;
    unsigned length;
  }; // TokenPosition
  
  /// A token consists of a string (the actual token), the token type assigned by the tokenizer and the token position
  struct Token 
  {
    Token() : _token_type(ttEOS) {}
    Token(const std::string& tok, TokenType t, const TokenPosition& pos)
    : _token(tok), _token_type(t), _position(pos) {}
    
    /// Converts a token to it's type  
    operator TokenType() const { return _token_type; }

    TokenType type() const { return _token_type; }
    const std::string& token() const { return _token; }
    const TokenPosition& position() const { return _position; }
 
    std::string   _token;
    TokenType     _token_type;
    TokenPosition _position;
  }; // Token

public:
  /// Constructor
  Tokenizer()
  : buffer(0), cursor(0), token_begin(0), limit(0), marker(0), 
    current_line_no(0), current_global_offs(0), looked_ahead(false)
  {}
  
  /// Pass a new line to the tokenizer
  void set_line(const char* line)
  {
    buffer = cursor = line;
    limit = line + std::string(line).size();
    marker = 0;
    ++current_line_no;
  }
  
  /// Returns the next token in input (will be generated by re2c)
  inline Token next_token()
  {
    if (looked_ahead) {
      looked_ahead = false;
      return lookahead_token;
    }
    else return next_token2();
  }

  /// Returns the lookahead token
  inline const Token& lookahead()
  {
    if (!looked_ahead) {
      lookahead_token = next_token();
      looked_ahead = true;
    }
    return lookahead_token;
  }

  /// Translate TokenType to string
  std::string translation(TokenType tt) const
  {
    if (tt == ttWord)               return "WORD";
    if (tt == ttGenSuffix)          return "GENITIVE_SUFFIX";
    if (tt == ttNumber)             return "NUMBER";
    if (tt == ttAbbrev)             return "ABBREV";
    if (tt == ttDate)               return "DATE";
    if (tt == ttPunct)              return "PUNCT";
    if (tt == ttLeftBracket)        return "L_BRACKET";
    if (tt == ttRightBracket)       return "R_BRACKET";
    if (tt == ttLeftQuote)          return "L_QUOTE";
    if (tt == ttRightQuote)         return "R_QUOTE";
    if (tt == ttHTMLEntity)         return "HTML-Entity";
    if (tt == ttHTML_XML)           return "XML/HTML";
    if (tt == ttNEAnnotation)       return "<ne>";
    if (tt == ttNEAnnotationEnd)    return "</ne>";
    if (tt == ttURL)                return "URL";
    if (tt == ttEmail)              return "EMAIL";
    if (tt == ttDash)               return "DASH";
    if (tt == ttCurrency)           return "CURRENCY";
    if (tt == ttSymbol)             return "SYMBOL";
    if (tt == ttMisc)               return "MISC";
    if (tt == ttJSONEscapedSymbol)  return "ESCSYMBOL";
    if (tt == ttJSONEscapedNewline) return "JSON_NL";
    if (tt == ttJSONEscapedQuote)   return "JSON_QUOTE";
    if (tt == ttUnicodePoint)       return "UNICODE_POINT";
    if (tt == ttRest)               return "REST";
    if (tt == ttEOS)                return "EOS";
    return "UNKNOWN";
  }
 
private: // Functions
  /// Returns the next token in input (will be generated by re2c)
  Token next_token2();

  /// Updates variables and returns a new token
  inline Token t_return(TokenType tt)
  { 
    unsigned len = cursor-token_begin;
//    return Token(std::string(token_begin,len),tt,TokenPosition(current_line_no,token_begin-buffer+1,len));
    Token t(std::string(token_begin,len),tt,TokenPosition(current_global_offs,len));
    current_global_offs += len;
    return t;
  }
  
  /// Returns an annotation token
  inline Token anno_return(TokenType tt)
  { 
    unsigned len = cursor-token_begin;
//    return Token(std::string(token_begin,len),tt,TokenPosition(current_line_no,token_begin-buffer+1,len));
    return Token(std::string(token_begin,len),tt,TokenPosition(current_global_offs,len));
  }

private: // Member variables
  const char*   buffer;               ///< buffer for input
  const char*   cursor;               ///< pointer to current input symbol in buffer
  const char*   token_begin;          ///< pointer to the begin of the current token
  const char*   limit;                ///< pointer behind last available input symbol in buffer
  const char*   marker;               ///< pointer into input for backtracking information
  unsigned      current_line_no;      ///< current line number
  unsigned      current_global_offs;  ///< offset since the beginning of the document
  Token         lookahead_token;      ///< 
  bool          looked_ahead;         ///< 
}; // Tokenizer


// Include the re2c generated tokenizing function
#ifdef PCRF_UTF8_SUPPORT
# include "next_utf8_token.cpp"
#else
# include "next_token.cpp"
#endif

#endif // __TOKENIZER_HPP__
